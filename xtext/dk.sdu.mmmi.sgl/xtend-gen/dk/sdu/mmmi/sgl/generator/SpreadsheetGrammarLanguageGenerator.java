/**
 * generated by Xtext
 */
package dk.sdu.mmmi.sgl.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Block;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.BlockSpec;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Column;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.ColumnDefinition;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.ColumnSpec;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Element;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Grammar;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.MandatoryColumn;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.OptionalColumn;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.RowSpec;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Rule;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Syntax;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.SyntaxSeq;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class SpreadsheetGrammarLanguageGenerator implements IGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterator<Grammar> _filter = Iterators.<Grammar>filter(_allContents, Grammar.class);
    final Procedure1<Grammar> _function = (Grammar it) -> {
      this.compile(it, fsa);
    };
    IteratorExtensions.<Grammar>forEach(_filter, _function);
  }
  
  public void compile(final Grammar grammar, final IFileSystemAccess fsa) {
    String _name = grammar.getName();
    String _plus = ("generated/Parser_" + _name);
    String _plus_1 = (_plus + ".py");
    CharSequence _generate = this.generate(grammar);
    fsa.generateFile(_plus_1, _generate);
  }
  
  public CharSequence generate(final Grammar grammar) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("from spreadsheet_parser import *");
    _builder.newLine();
    _builder.append("class Parse");
    String _name = grammar.getName();
    _builder.append(_name, "");
    _builder.append("(GenericParserHelper):");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def __init__(self, spreadsheet):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("GenericParserHelper.__init__(self,spreadsheet)");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def matchColumns(self,columnHeaders):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return columnHeaders==[");
    {
      List<String> _computeHeaders = this.computeHeaders(grammar);
      boolean _hasElements = false;
      for(final String h : _computeHeaders) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t\t");
        }
        _builder.append("\"");
        _builder.append(h, "\t\t");
        _builder.append("\"");
      }
    }
    _builder.append("]");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def getColumnHeaders(self):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return [");
    {
      List<String> _computeHeaders_1 = this.computeHeaders(grammar);
      boolean _hasElements_1 = false;
      for(final String h_1 : _computeHeaders_1) {
        if (!_hasElements_1) {
          _hasElements_1 = true;
        } else {
          _builder.appendImmediate(",", "\t\t");
        }
        _builder.append("\"");
        _builder.append(h_1, "\t\t");
        _builder.append("\"");
      }
    }
    _builder.append("]");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def parseBlock(self,columnHeaders,row,column,height):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("self.debug_trace(\"parseBlock\",row,column)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("results = []");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("relativeRow = 0");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("while relativeRow<height:");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("increment_and_object = self.parse_");
    Block _root = grammar.getRoot();
    String _name_1 = _root.getName();
    _builder.append(_name_1, "\t\t\t");
    _builder.append("(row+relativeRow,column,row+height)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("results.append(increment_and_object[1])");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("relativeRow += increment_and_object[0]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return results");
    _builder.newLine();
    {
      EList<Element> _elements = grammar.getElements();
      for(final Element e : _elements) {
        _builder.append("\t");
        CharSequence _genParser = this.genParser(e);
        _builder.append(_genParser, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  protected CharSequence _genParser(final Block block) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("def parse_");
    String _name = block.getName();
    _builder.append(_name, "");
    _builder.append("(self,row,column,max_row):");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("self.debug_trace(\"parse_");
    String _name_1 = block.getName();
    _builder.append(_name_1, "\t");
    _builder.append("\",row,column)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("column_offset = 0");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("result_row_increment = 1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("result_object = {}");
    _builder.newLine();
    {
      EList<Column> _columns = block.getColumns();
      for(final Column c : _columns) {
        _builder.append("\t");
        _builder.append("# Column ");
        String _name_2 = c.getName();
        _builder.append(_name_2, "\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("current_column = column+column_offset");
        _builder.newLine();
        {
          boolean _isMultiple = c.isMultiple();
          if (_isMultiple) {
            _builder.append("\t");
            ColumnDefinition _def = c.getDef();
            String _name_3 = c.getName();
            CharSequence _genParserMultiple = this.genParserMultiple(_def, _name_3);
            _builder.append(_genParserMultiple, "\t");
            _builder.newLineIfNotEmpty();
          } else {
            _builder.append("\t");
            ColumnDefinition _def_1 = c.getDef();
            String _name_4 = c.getName();
            CharSequence _genParserSingle = this.genParserSingle(_def_1, _name_4);
            _builder.append(_genParserSingle, "\t");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append("result_object[\"");
        String _name_5 = c.getName();
        _builder.append(_name_5, "\t");
        _builder.append("\"] = value_");
        String _name_6 = c.getName();
        _builder.append(_name_6, "\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("column_offset += 1");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.append("return (result_row_increment,result_object)");
    _builder.newLine();
    return _builder;
  }
  
  protected CharSequence _genParserMultiple(final MandatoryColumn col, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("value_");
    _builder.append(name, "");
    _builder.append(" = []");
    _builder.newLineIfNotEmpty();
    ColumnSpec _spec = col.getSpec();
    CharSequence _genParserMultipleBody = this.genParserMultipleBody(_spec, name);
    _builder.append(_genParserMultipleBody, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _genParserMultiple(final OptionalColumn col, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("value_");
    _builder.append(name, "");
    _builder.append(" = []");
    _builder.newLineIfNotEmpty();
    _builder.append("if not self.emptyCell(row,current_column):");
    _builder.newLine();
    _builder.append("\t");
    ColumnSpec _spec = col.getSpec();
    CharSequence _genParserMultipleBody = this.genParserMultipleBody(_spec, name);
    _builder.append(_genParserMultipleBody, "\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _genParserSingle(final MandatoryColumn col, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("value_");
    _builder.append(name, "");
    _builder.append(" = ");
    ColumnSpec _spec = col.getSpec();
    CharSequence _genParserSingleBody = this.genParserSingleBody(_spec);
    _builder.append(_genParserSingleBody, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _genParserSingle(final OptionalColumn col, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("if self.emptyCell(row,current_column):");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("value_");
    _builder.append(name, "\t");
    _builder.append(" = None");
    _builder.newLineIfNotEmpty();
    _builder.append("else:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("value_");
    _builder.append(name, "\t");
    _builder.append(" = ");
    ColumnSpec _spec = col.getSpec();
    CharSequence _genParserSingleBody = this.genParserSingleBody(_spec);
    _builder.append(_genParserSingleBody, "\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _genParserSingleBody(final RowSpec spec) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("self.debug_trace_2(\"parse_syntax_");
    Syntax _syntax = spec.getSyntax();
    String _generateSyntaxName = this.generateSyntaxName(_syntax);
    _builder.append(_generateSyntaxName, "");
    _builder.append("\",row,current_column,lambda:self.parse_syntax_");
    Syntax _syntax_1 = spec.getSyntax();
    String _generateSyntaxName_1 = this.generateSyntaxName(_syntax_1);
    _builder.append(_generateSyntaxName_1, "");
    _builder.append("(self.getCell(row,current_column)))");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _genParserSingleBody(final BlockSpec spec) {
    try {
      throw new Exception("Illegal grammar: block with single-relation column");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  protected CharSequence _genParserMultipleBody(final RowSpec spec, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("relativeRow = 0");
    _builder.newLine();
    _builder.append("while True:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("self.debug_trace(\"parse_syntax_");
    Syntax _syntax = spec.getSyntax();
    String _generateSyntaxName = this.generateSyntaxName(_syntax);
    _builder.append(_generateSyntaxName, "\t");
    _builder.append("\",row+relativeRow,current_column)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("value_");
    _builder.append(name, "\t");
    _builder.append(".append(self.parse_syntax_");
    Syntax _syntax_1 = spec.getSyntax();
    String _generateSyntaxName_1 = this.generateSyntaxName(_syntax_1);
    _builder.append(_generateSyntaxName_1, "\t");
    _builder.append("(self.getCell(row+relativeRow,current_column))");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("relativeRow += 1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("if not self.emptyCell(row+relativeRow,current_column-1):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("break");
    _builder.newLine();
    _builder.append("result_row_increment = max(result_row_increment,relativeRow)");
    _builder.newLine();
    return _builder;
  }
  
  protected CharSequence _genParserMultipleBody(final BlockSpec spec, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("relativeRow = 0");
    _builder.newLine();
    _builder.append("while True:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("if row+relativeRow>=max_row:");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("break");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("self.debug_trace(\"parse_syntax_");
    Block _kind = spec.getKind();
    String _name = _kind.getName();
    _builder.append(_name, "\t");
    _builder.append("\",row+relativeRow,current_column)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("increment_and_object = self.parse_");
    Block _kind_1 = spec.getKind();
    String _name_1 = _kind_1.getName();
    _builder.append(_name_1, "\t");
    _builder.append("(row+relativeRow,current_column,max_row)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("relativeRow += increment_and_object[0]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("value_");
    _builder.append(name, "\t");
    _builder.append(".append(increment_and_object[1])");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("if not self.emptyCell(row+relativeRow,current_column-1):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("break");
    _builder.newLine();
    _builder.append("result_row_increment = max(result_row_increment,relativeRow)");
    _builder.newLine();
    return _builder;
  }
  
  public String generateSyntaxName(final Syntax syntax) {
    String _xifexpression = null;
    boolean _isIs_id = syntax.isIs_id();
    if (_isIs_id) {
      _xifexpression = "IDENTIFIER";
    } else {
      String _xifexpression_1 = null;
      boolean _isIs_string = syntax.isIs_string();
      if (_isIs_string) {
        _xifexpression_1 = "STRING";
      } else {
        String _xifexpression_2 = null;
        boolean _isIs_int = syntax.isIs_int();
        if (_isIs_int) {
          _xifexpression_2 = "INTEGER";
        } else {
          String _xifexpression_3 = null;
          String _token = syntax.getToken();
          boolean _notEquals = (!Objects.equal(_token, null));
          if (_notEquals) {
            String _token_1 = syntax.getToken();
            String _plus = ("token(\"" + _token_1);
            _xifexpression_3 = (_plus + "\")");
          } else {
            Rule _rule = syntax.getRule();
            _xifexpression_3 = _rule.getName();
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  protected CharSequence _genParser(final Rule rule) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("def parse_syntax_");
    String _name = rule.getName();
    _builder.append(_name, "");
    _builder.append("(self,text):");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("object_and_rest = self.internal_parse_syntax_");
    String _name_1 = rule.getName();
    _builder.append(_name_1, "\t");
    _builder.append("(text)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("if object_and_rest==None:");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("raise Exception(\"Failed parsing as ");
    String _name_2 = rule.getName();
    _builder.append(_name_2, "\t\t");
    _builder.append(", text: \"+text)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("rest_maybe = object_and_rest[1].lstrip()");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("if len(rest_maybe)>0:");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("raise Exception(\"Surplus text when parsing ");
    String _name_3 = rule.getName();
    _builder.append(_name_3, "\t\t");
    _builder.append(", text: \"+rest_maybe)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("return object_and_rest[0]");
    _builder.newLine();
    _builder.newLine();
    _builder.append("def internal_parse_syntax_");
    String _name_4 = rule.getName();
    _builder.append(_name_4, "");
    _builder.append("(self,text):");
    _builder.newLineIfNotEmpty();
    {
      EList<SyntaxSeq> _alternatives = rule.getAlternatives();
      for(final SyntaxSeq a : _alternatives) {
        _builder.append("\t");
        _builder.append("object_and_rest = self.parse_syntax_");
        String _name_5 = rule.getName();
        _builder.append(_name_5, "\t");
        _builder.append("_");
        String _uniqueCode = this.uniqueCode(a);
        _builder.append(_uniqueCode, "\t");
        _builder.append("(text)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("if object_and_rest!=None:");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("return object_and_rest");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.append("return None");
    _builder.newLine();
    {
      EList<SyntaxSeq> _alternatives_1 = rule.getAlternatives();
      for(final SyntaxSeq a_1 : _alternatives_1) {
        EList<Syntax> _parts = a_1.getParts();
        String _name_6 = rule.getName();
        String _plus = (_name_6 + "_");
        String _uniqueCode_1 = this.uniqueCode(a_1);
        String _plus_1 = (_plus + _uniqueCode_1);
        String _name_7 = rule.getName();
        CharSequence _genInternalParser = this.genInternalParser(_parts, _plus_1, _name_7);
        _builder.append(_genInternalParser, "");
        _builder.append("\t");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence genInternalParser(final EList<Syntax> list, final String name, final String dataname) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("def parse_syntax_");
    _builder.append(name, "");
    _builder.append("(self,text):");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("current = text");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("result = []");
    _builder.newLine();
    {
      for(final Syntax part : list) {
        _builder.append("\t");
        _builder.append("object_and_rest = self.internal_parse_syntax_");
        String _generateSyntaxName = this.generateSyntaxName(part);
        _builder.append(_generateSyntaxName, "\t");
        _builder.append("(current)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("if object_and_rest==None:");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("return None");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("result.append(object_and_rest[0])");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("current = object_and_rest[1]");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.append("return ({\"");
    _builder.append(dataname, "\t");
    _builder.append("\":result},current)");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public String uniqueCode(final SyntaxSeq seq) {
    String _xblockexpression = null;
    {
      boolean _containsKey = this.uniqueCodes.containsKey(seq);
      boolean _not = (!_containsKey);
      if (_not) {
        int _plusPlus = this.uniqueCodesCounter++;
        String _string = Integer.toString(_plusPlus);
        this.uniqueCodes.put(seq, _string);
      }
      _xblockexpression = this.uniqueCodes.get(seq);
    }
    return _xblockexpression;
  }
  
  private final HashMap<SyntaxSeq, String> uniqueCodes = new HashMap<SyntaxSeq, String>();
  
  private int uniqueCodesCounter = 0;
  
  public List<String> computeHeaders(final Grammar grammar) {
    ArrayList<String> _xblockexpression = null;
    {
      final ArrayList<String> result = new ArrayList<String>();
      Block _root = grammar.getRoot();
      this.collectHeaders(_root, result);
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
  
  protected void _collectHeaders(final Block block, final List<String> collector) {
    EList<Column> _columns = block.getColumns();
    final Consumer<Column> _function = (Column it) -> {
      this.collectHeaders(it, collector);
    };
    _columns.forEach(_function);
  }
  
  protected void _collectHeaders(final Rule rule, final List<String> collector) {
  }
  
  protected void _collectHeaders(final Column column, final List<String> collector) {
    ColumnDefinition _def = column.getDef();
    this.collectHeaders(_def, collector);
  }
  
  protected void _collectHeaders(final ColumnDefinition cdef, final List<String> collector) {
    ColumnSpec _spec = cdef.getSpec();
    this.collectHeaders(_spec, collector);
  }
  
  protected void _collectHeaders(final RowSpec spec, final List<String> collector) {
    String _header = spec.getHeader();
    collector.add(_header);
  }
  
  protected void _collectHeaders(final BlockSpec spec, final List<String> collector) {
    Block _kind = spec.getKind();
    this.collectHeaders(_kind, collector);
  }
  
  public CharSequence genParser(final Element block) {
    if (block instanceof Block) {
      return _genParser((Block)block);
    } else if (block instanceof Rule) {
      return _genParser((Rule)block);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(block).toString());
    }
  }
  
  public CharSequence genParserMultiple(final ColumnDefinition col, final String name) {
    if (col instanceof MandatoryColumn) {
      return _genParserMultiple((MandatoryColumn)col, name);
    } else if (col instanceof OptionalColumn) {
      return _genParserMultiple((OptionalColumn)col, name);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(col, name).toString());
    }
  }
  
  public CharSequence genParserSingle(final ColumnDefinition col, final String name) {
    if (col instanceof MandatoryColumn) {
      return _genParserSingle((MandatoryColumn)col, name);
    } else if (col instanceof OptionalColumn) {
      return _genParserSingle((OptionalColumn)col, name);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(col, name).toString());
    }
  }
  
  public CharSequence genParserSingleBody(final ColumnSpec spec) {
    if (spec instanceof BlockSpec) {
      return _genParserSingleBody((BlockSpec)spec);
    } else if (spec instanceof RowSpec) {
      return _genParserSingleBody((RowSpec)spec);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(spec).toString());
    }
  }
  
  public CharSequence genParserMultipleBody(final ColumnSpec spec, final String name) {
    if (spec instanceof BlockSpec) {
      return _genParserMultipleBody((BlockSpec)spec, name);
    } else if (spec instanceof RowSpec) {
      return _genParserMultipleBody((RowSpec)spec, name);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(spec, name).toString());
    }
  }
  
  public void collectHeaders(final EObject block, final List<String> collector) {
    if (block instanceof Block) {
      _collectHeaders((Block)block, collector);
      return;
    } else if (block instanceof BlockSpec) {
      _collectHeaders((BlockSpec)block, collector);
      return;
    } else if (block instanceof RowSpec) {
      _collectHeaders((RowSpec)block, collector);
      return;
    } else if (block instanceof Rule) {
      _collectHeaders((Rule)block, collector);
      return;
    } else if (block instanceof Column) {
      _collectHeaders((Column)block, collector);
      return;
    } else if (block instanceof ColumnDefinition) {
      _collectHeaders((ColumnDefinition)block, collector);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(block, collector).toString());
    }
  }
}
